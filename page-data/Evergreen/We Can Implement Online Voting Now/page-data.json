{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Evergreen/We Can Implement Online Voting Now","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Why don't we already do online voting? I know that technology is susceptible to attacks, but we have some pretty solid cryptography already. We could use asymmetric encryption to solve the issue of one vote per person, verifying that the vote was made by the person who owned the private key, and not expose who they voted for.\"), mdx(\"p\", null, \"Imagine that instead of (or alongside) mail-in voting where we mail ballots to people, that voters could opt-in to receiving a YubiKey that was tied to their SSN or some other identifier and use that to vote. The process could go like this:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The voter would receive the YubiKey in the mail or pick it up at their nearest official place to get one.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When it comes time to vote, they would go to an official government site and activate the YubiKey, verifying their identity with SSN or driver's license or something else.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Once the key is activated, it has a public key tied to the person, and can be used to vote once. After it's used to vote, its key will be rejected in further attempts to vote so it can't be reused.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When the key is used to vote, the identity of the user isn't sent, just the vote increment. ==This is the part of the idea that I think needs work, being able to provably increment the vote count and having the increment be valid without leaking the user's identity. Or we could just be ok with public voting as a society.==\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Afterwards, the user can return the YubiKey via mail or drop off, and the key can be reset and reused in the future.\")), mdx(\"p\", null, \"This way, people can securely vote online, ensuring that one person only votes once (we'd need some sort of infrastructure to prevent voting by both paper ballot and online), and the identity of the voter can't be tied to who/what they voted for.\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[]},"fields":{"slug":"/Evergreen/We Can Implement Online Voting Now","title":"We Can Implement Online Voting Now"}}},"pageContext":{"id":"8dbc8b4f-ac3f-5e15-aefb-0a2e8eee022c"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}