{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Code Diary/Scaling React Server Side Rendering","result":{"data":{"file":{"childMdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Learnings from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://arkwright.github.io/scaling-react-server-side-rendering.html\"\n  }, \"https://arkwright.github.io/scaling-react-server-side-rendering.html\")), mdx(\"h1\", {\n    \"id\": \"load-balancing\"\n  }, \"Load Balancing\"), mdx(\"h2\", {\n    \"id\": \"random-load-balancing-is-bad\"\n  }, \"Random load balancing is bad\"), mdx(\"p\", null, \"It may seem intuitive that over time it would evenly distribute load, but at any individual \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"moment\"), \", load will be uneven (flip a coin and see, while it's random with 50% chance of either side, at any particular instance the counts of H to T will likely be uneven). E.g. some instances will be getting more requests than others.\"), mdx(\"h2\", {\n    \"id\": \"whats-a-better-load-balancing-strategy\"\n  }, \"What's a better load balancing strategy?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interesting presentation: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.infoq.com/presentations/load-balancing/\"\n  }, \"https://www.infoq.com/presentations/load-balancing/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Random load balancing with load shedding at each instance, so that the balancer randomly tries another instance, is better than load queueing. Still bad though as this adds latency and as load saturation increases, chance of hitting a free instance decreases.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Round-robin is better than above as it ensures that \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"requests\"), \" are distributed evenly, but not \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"load\"), \". One request may take longer to render than another, for example.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Join-shortest-queue, load balancer will send to instance with shortest queue using some heuristic, e.g. number of requests in queue, or something else that can approximate load\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Note that while random load balancing is bad, it is not bad to have multiple load balancers and randomly select from them, provided each balancer implements a better balancing strategy to the instances that process requests. Load balancers can typically handle all network traffic easily by themselves, having more than one allows failover capability.\")), mdx(\"h1\", {\n    \"id\": \"isomorphic-rendering\"\n  }, \"Isomorphic Rendering\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"How to scale server-side rendering when spinning up horizontal instances isn't feasible Easy, just don't use server-side rendering! If you use something like Redux, or anything that can make total application state easily serializable (maybe total application state isn't necessary, but let's required application state), you can skip the SSR if servers are under load (just pass the serialized state along, e.g. the data) and just have the user's browser do it. At least that way the response time is faster.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To me, this model at first glance seems like it could work with Remix. Remix is about getting the data on the server side and rendering and passing to the user. Well, the data is usually the longest part (network request), so surely we can just pass that along and do client side rendering fallback with Remix as well? Requires further investigation.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Although, it seems that in general Isomorphic rendering is to only render the first page and let the client handle the rest, whereas Remix is about always using SSR. Perhaps Remix can get away with this because it is used in infrastructures where horizontal scaling is easy, e.g. Lambdas/Azure Functions/Cloudflare Workers?\")))))), mdx(\"p\", null, \"Quoting the good part below\"), mdx(\"h2\", {\n    \"id\": \"how-it-works\"\n  }, \"How It Works\"), mdx(\"p\", null, \"Building a client-side rendering fallback system is remarkably straightforward.\"), mdx(\"p\", null, \"The Node server simply maintains a request queue length counter. For every request received, increment the counter, and for every error or response sent, decrement the counter. When the queue length is less than or equal to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \", perform regular data fetching, Redux store hydration, and a server-side React render. When the queue length is greater than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \", skip the server-side React rendering part \\u2014 the browser will handle that, using the data from the Redux store.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://arkwright.github.io/images/scaling-react-server-side-rendering/client-side-rendering-fallback-queue.svg\",\n    \"alt\": \"Diagram of how client-side rendering fallback acts as a kind of load throttling. Monolith sends 7 requests to the React service. The first request is server-side rendered, because at that point in time, the service has 0 requests in queue. The next 6 requests are triaged and queued. The first 2 requests are queued for server-side rendering, because we have arbitrarily chosen a queue length of < 3 as our light load cutoff for server-side rendering. The next 3 requests are queued for client-side rendering, because we have arbitrarily chosen a queue length of < 6 as our heavy load cutoff for client-side rendering. The final request exceeds our maximum queue length, and is dropped in order to shed load.\"\n  })), mdx(\"p\", null, \"The exact value of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" will need to be tuned to match the characteristics of your application. Generally speaking, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" should be slightly larger than the typical queue length during peak expected load.\"), mdx(\"p\", null, \"Of course, if SEO is a requirement, this approach contains a slight problem: if a search engine crawls the site during a traffic surge, it may not receive a server-side rendered response, and therefore it may not index your pages! Fortunately this is an easy problem to solve: provide an exception for known search engine user agent strings.\"), mdx(\"h1\", {\n    \"id\": \"load-shedding\"\n  }, \"Load Shedding\"), mdx(\"p\", null, \"Instead of load balancer sending requests directly to instances that do the render, forward requests to a cluster, where a master process decides whether its workers have capacity and forwards the request to one of them, or if no capacity, will return a 503 to the load balancer so it can try another cluster, or forward it along to the client so a fallback can occur.\"), mdx(\"h1\", {\n    \"id\": \"component-caching\"\n  }, \"Component Caching\"), mdx(\"p\", null, \"I.e. render the TSX/JSX template \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Greeting name=\\\"Rudy\\\" />\"), \" into HTML \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<p>Hi, Rudy</p>\"), \". Here's an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/electrode-io/electrode-react-ssr-caching\"\n  }, \"example library\"), \". Note that while this does make renders super fast, it has some big cons:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This library in particular is tied to a specific version of React as it mutates some of its core APIs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There are a lot of gotchas for deciding when to invalidate the cache/make sure you don't cache everything and run out of memory, etc. \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"\\\"There are only two hard things in Computer Science: cache invalidation and naming things.\\\" \\u2014 Phil Karlton\"))), mdx(\"p\", null, \"It would seem that component caching should only be used for components that don't change very often/don't vary based on the user, e.g. header, nav, footer, etc.\"), mdx(\"h1\", {\n    \"id\": \"keep-dependencies-up-to-date\"\n  }, \"Keep dependencies up to date\"), mdx(\"p\", null, \"You can get free performance gains by just updating Node and React versions, so do it.\"), mdx(\"h1\", {\n    \"id\": \"know-what-to-work-on-first-during-incremental-rewrites\"\n  }, \"Know what to work on first during incremental rewrites\"), mdx(\"p\", null, \"E.g. converting an entire non-React app to React is usually off the table as it's too expensive and will take too long, so incremental change is required. Make sure to pick the right stuff to convert in such a case, e.g. don't invest your time on optimizing rare cases. Quote (imagine app with page flow of Home -> Search -> Product):\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"But it\\u2019s easy to miss out on these strategic pairings. Let\\u2019s say your search results page is where all of the money is made, and so the product team is hesitant to modify it. If we invest our time into improving the home and product pages, making them isomorphic in the process, we won\\u2019t see much uptake in client-side rendering. This is because in order to get from the homepage to a product page, most users will navigate \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"through\"), \" a search results page. Because the search results page is not isomorphic, a server-side render will be required. If we\\u2019re not careful, it\\u2019s easy to perform a kind of inverse \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Pareto_principle\"\n  }, \"Pareto optimization\"), \", investing 80% of the resources to achieve only 20% of the gains.\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[]},"fields":{"slug":"/Code Diary/Scaling React Server Side Rendering","title":"Load Balancing"}}},"pageContext":{"id":"31929880-f8ba-50f2-a77b-020da5e49aa5"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}